/**
*  @license
* Copyright 2022, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/

import { Scalar, Tensor1D, Tensor2D } from '@tensorflow/tfjs-node'
import { assert } from 'console'
import { tf } from '../shared/globals'
import { CrossValidator } from './crossValidator'
import { KFold } from './kFold'

/**
 * Evaluates a score by cross-validation. This particular overload
 * of the function uses the given scorer function to cross validate
 * a superwised estimator.
 *
 * @param estimator A supervised estimator that has an async `fit(X,y)` function.
 *
 * @param Xy       A two element array containing the features and targets
 *                 of the cross validation dataset.
 *
 * @param params   Cross validation parameters. `cv` is the {@link CrossValidator}
 *                 responsible for splitting the dataset into training in test
 *                 data in one or more folds. `groups` is additional grouping
 *                 information which is used by some {@link CrossValidator}
 *                 instance to determine which groups of datapoints may not
 *                 appear both in test and training data at the same time.
 *                 `scoring` is the scorer function which is being called
 *                 with `estimator` as `this` and the test features `X_test`
 *                 and targets `y_test` as arguments.
 *
 * @returns        The test score for each split/fold that was generated by
 *                 the {@link CrossValidator} `cv`
 */
export async function crossValScore<
  T extends {
    fit(X: Tensor2D, y: Tensor1D): Promise<unknown>
  }
>(
  estimator: T,
  Xy: [Tensor2D, Tensor1D],
  params: {
    cv?: CrossValidator
    groups?: Tensor1D
    scoring: (this: T, X: Tensor2D, y: Tensor1D) => Scalar
  }
): Promise<Tensor1D>

/**
 * Evaluates a score by cross-validation. This particular overload
 * of the function uses the given scorer to cross validate an
 * unsuperwised estimator.
 *
 * @param estimator A supervised estimator that has an async `fit(X)` function.
 *
 * @param X        An single element array containing the features of the
 *                 cross validation dataset.
 *
 * @param params   Cross validation parameters. `cv` is the {@link CrossValidator}
 *                 responsible for splitting the dataset into training in test
 *                 data in one or more folds. `groups` is additional grouping
 *                 information which is used by some {@link CrossValidator}
 *                 instance to determine which groups of datapoints may not
 *                 appear both in test and training data at the same time.
 *                 `scoring` is the scorer function which is being called
 *                 with `estimator` as `this` and the test features `X_test`
 *                 as argument.
 *
 * @returns        The test score for each split/fold that was generated by
 *                 the {@link CrossValidator} `cv`
 */
export async function crossValScore<
  T extends {
    fit(X: Tensor2D): Promise<unknown>
  }
>(
  estimator: T,
  X: [Tensor2D],
  params: {
    cv?: CrossValidator
    groups?: Tensor1D
    scoring: (this: T, X: Tensor2D) => Scalar
  }
): Promise<Tensor1D>

/**
 * Evaluates a score by cross-validation. This particular overload
 * of the function uses the default score of a superwised estimator
 * for scoring.
 *
 * @param estimator A supervised estimator that has an async `fit(X,y)`
 *                 function and a `score(X,y)` function.
 *
 * @param Xy       A two element array containing the features and targets
 *                 of the cross validation dataset.
 *
 * @param params   Cross validation parameters. `cv` is the {@link CrossValidator}
 *                 responsible for splitting the dataset into training in test
 *                 data in one or more folds. `groups` is additional grouping
 *                 information which is used by some {@link CrossValidator}
 *                 instance to determine which groups of datapoints may not
 *                 appear both in test and training data at the same time.
 *
 * @returns        The test score for each split/fold that was generated by
 *                 the {@link CrossValidator} `cv`
 */
export async function crossValScore(
  estimator: {
    fit(X: Tensor2D, y: Tensor1D): Promise<unknown>
    score(X: Tensor2D, y: Tensor1D): Scalar
  },
  Xy: [Tensor2D, Tensor1D],
  params: {
    cv?: CrossValidator
    groups?: Tensor1D
  }
): Promise<Tensor1D>

/**
 * Evaluates a score by cross-validation. This particular overload
 * of the function uses the default score of an unsuperwised estimator
 * for scoring.
 *
 * @param estimator A supervised estimator that has an async `fit(X)`
 *                 function and a `score(X)` function.
 *
 * @param X        An single element array containing the features of the
 *                 cross validation dataset.
 *
 * @param params   Cross validation parameters. `cv` is the {@link CrossValidator}
 *                 responsible for splitting the dataset into training in test
 *                 data in one or more folds. `groups` is additional grouping
 *                 information which is used by some {@link CrossValidator}
 *                 instance to determine which groups of datapoints may not
 *                 appear both in test and training data at the same time.
 *
 * @returns        The test score for each split/fold that was generated by
 *                 the {@link CrossValidator} `cv`
 */
export async function crossValScore(
  estimator: {
    fit(X: Tensor2D): Promise<unknown>
    score(X: Tensor2D): Scalar
  },
  X: [Tensor2D, Tensor1D],
  params: {
    cv?: CrossValidator
    groups?: Tensor1D
  }
): Promise<Tensor1D>

export async function crossValScore(
  estimator: any,
  [X, y]: [Tensor2D, Tensor1D?],
  {
    cv = new KFold(),
    groups,
    scoring
  }: {
    cv?: CrossValidator
    groups?: Tensor1D
    scoring?: any
  } = {}
): Promise<Tensor1D> {
  if (undefined === scoring) {
    assert(
      'function' === typeof estimator.score,
      'crossValScore(estimator,[X,y],params): Either params.scoring or estimator.score(X,y) must be defined.'
    )
    scoring = estimator.score
  }

  const scores: Scalar[] = []
  scoring = scoring.bind(estimator)

  let result: Tensor1D | undefined = undefined

  tf.engine().startScope()
  try {
    for (const { trainIndex, testIndex } of cv.split(X, y, groups)) {
      let score: Scalar | undefined

      tf.engine().startScope()
      try {
        await estimator.fit(X.gather(trainIndex), y?.gather(trainIndex))

        score = scoring(X.gather(testIndex), y?.gather(testIndex)) as Scalar
        scores.push(score)
      } finally {
        tf.engine().endScope(score)
        trainIndex.dispose()
        testIndex.dispose()
      }
    }

    return (result = tf.stack(scores) as Tensor1D)
  } finally {
    tf.engine().endScope(result)
  }
}
